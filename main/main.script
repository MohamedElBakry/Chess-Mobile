local utils = utils or require "utils-module.utils"
local piece = piece or require "piece.piece"
local rendercam = require "rendercam.rendercam"
local ai = ai or require "game.ai"

local piece_array = {}

local GAME_STATE = utils.enum({"START", "END", "TURN_WHITE", "TURN_BLACK", "WIN_WHITE", "WIN_BLACK", "STALEMATE"})
local current_state = GAME_STATE.TURN_WHITE

-- Keeps track of the last moved piece for (w)hite and (b)lack, so we can determine if en passant is truly valid
-- See Piece:__isvalid_pawn
local team_colour = {
	["w"] = {last_moved_piece_id = nil}, 
	["b"] = {last_moved_piece_id = nil}
}


function init(self)
	msg.post(".", "acquire_input_focus")
end


function on_message(self, message_id, message)
	print("MESSAGE:", message_id, message.id)
	if message_id == hash("piece_array") then
		piece_array = message.id

		-- Loop through the piece array and replace 'constructor' tables with Piece function-objects
		for x, row in ipairs(piece_array) do
			for y, piece_table in ipairs(row) do
				local piece = utils.deepcopy(Piece:new(piece_table["id"], piece_table["name"], {x, y}, false))
				
				-- Replace the piece_table with the Piece function-object
				piece_array[x][y] = piece
				
			end
		end

		-- TODO: check piece move validation
		-- TODO: on piece click -- highlight valid moves
		-- print("positions: ***", ai.move_gen_test(1, piece_array))
		-- print(ai.search(2, piece_array), "<---- SEARCH RESULT")
	end
	
	-- Move Validation
	if message_id == hash("is_valid") then

		-- Get piece
		go_id = message.id[1]
		local move_from = get_piece_location(go_id)
		local move_to = message.id[2]
		print(move_from[1], move_from[2], "-->", move_to[1], move_to[2])

		-- Error check
		if move_from[1] == nil then
			print("move_from is nil... returning")
			return
		end

		-- Bounds check
		if (move_to[1] < 1 or move_to[1] > 8) or (move_to[2] < 1 or move_to[2] > 8) then
			centre(move_from, go_id, piece_array[move_from[1]][move_from[2]].scale)
			print("Out of bounds")
			return
		end
		
		-- Get the piece
		local piece = utils.deepcopy(piece_array[move_from[1]][move_from[2]])
		
		local valid, flag = piece:isValid(move_to, piece_array)
		print("VALIDITY:", valid, "FLAG:", flag)

		-- The king being in check overrides any move validation unless it's the king moving out of check
		-- as the king validation function would prevent that from happening
		valid = is_king_not_checkable(valid, move_to, piece, piece_array, flag)
		
		-- Final check that overrides all other checks to see if the correct team is moving a piece
		-- current_state, valid = get_turn(current_state, valid, piece.colour)
		if valid then
			get_king(piece.colour, piece_array).isChecked = false
		end

		if valid == false then
			piece:centre()
			show(piece_array)
			return
		end

		-- TODO: rename team_colour to last_moved_piece_by["colour"]
		piece:move(move_to, flag, piece_array, team_colour)
		
		-- Centre the piece in case it glitches out and just hovers over the captured square
		-- centre(piece.pos, piece.id, piece.scale)

		-- ::castled::
		-- Track the last moved piece for en passant
		team_colour[piece.colour]["last_moved_piece_id"] = piece.id

		-- CHECKMATE?
		-- If the enemy king is in check, and has no valid moves,
		-- and there are no moves by his pieces that will put him out of check, then there's a winner
		local game_over = is_checkmate(piece.colour, piece_array)
		if game_over and current_state == GAME_STATE.TURN_WHITE then
			current_state = GAME_STATE.WIN_WHITE
			
		elseif game_over and current_state == GAME_STATE.TURN_BLACK then
			current_state = GAME_STATE.WIN_BLACK
		end

		-- Stalemate?
		
	-- else
		-- If the move is invalid, just take the piece back to the move_from location
		-- centre(move_from, piece.id, piece.scale)
		
	-- end
	end

	show(piece_array)

	-- print(ai.evaluate(piece_array))
	
	
	return
end

function on_input(self, action_id, action)

	-- Show the valid moves
	-- if action_id == hash("touch") then
	-- 	local action_pos = rendercam.screen_to_world_2d(action.screen_x, action.screen_y)
	-- 	local board_coords = utils.px_to_xy({action_pos.x, action_pos.y})
	-- 	
	-- 	if board_coords and board_coords[1] > 8 or board_coords[1] < 1 or board_coords[2] > 8 or board_coords[2] < 1 then
	-- 		return
	-- 	end
	-- 	
	-- 	local piece = piece_array[board_coords[1]][board_coords[2]]
	-- 	local moves = piece:get_valid_moves(piece_array)
	-- end
	
	
end

-- [[ Helper Functions ]]
-- TODO: Make Game class to 'do' and undo moves? 


function show(piece_array)
	local row_str = ""
	for x = 1, 8 do
		for y = 1, 8 do
			if piece_array[x][y] ~= nil then
				row_str = row_str .. piece_array[x][y].name .. ", "
			else
				row_str = row_str .. "  " .. ", "
			end
		end
		print(row_str)
		row_str = ""
	end
	return
end


-- function centre(piece_pos, piece_id, piece_scale)
-- 	local pos = vmath.vector3(utils.get_px_from(piece_pos[2]), utils.get_px_from(utils.arr_coords[piece_pos[1]]), 0)
-- 	go.set_position(pos, piece_id)
-- 
-- 	-- Change to piece.scale
-- 	go.set_scale(piece_scale, piece_id)
-- 	
-- end

-- Validation helper function(s)

function get_piece_location(go_id)
	local move_from = {}

	-- Get piece
	for x = 1, 8 do
		for y = 1, 8 do
			if piece_array[x][y] ~= nil then
				if piece_array[x][y].id == go_id then
					move_from = {x, y}
				end
			end
		end
	end

	return move_from
end


-- TODO: Stalemate: king has 0 moves, he isn't in check, and his pieces have 0 moves
function is_checkmate(piece_colour, piece_array)
	
	local enemy_colour = "w"
	if piece_colour == "w" then
		enemy_colour = "b"
	end

	local enemy_king = get_king(enemy_colour, piece_array)

	-- Check if the enemy king is now in check
	local our_piece, our_piece_flag
	for x = 1, 8 do 
		for y = 1, 8 do
			our_piece = piece_array[x][y]

			if our_piece ~= nil and our_piece.colour == piece_colour then
				
				our_piece_valid, our_piece_flag = our_piece:isValid(enemy_king.pos, piece_array)
				if our_piece_valid and our_piece_flag == "capture" then
					enemy_king.isChecked = true
					goto is_checked
				end
			end
		end
	end

	::is_checked::
	if enemy_king.isChecked == false then
		print("The " .. enemy_colour .. " king is not threatend")
		-- Stalemate if king has 0 valid moves and all his pieces have 0 valid moves
		local all_pieces_moves
		if table.getn(enemy_king:get_valid_moves(piece_array)) == 0 then
			-- TODO: currently wrong -- for every row, return if the first piece of that row has valid moves
			-- Change to every piece of that row
			all_pieces_moves = utils.map(
			function(row)
				for x = 1, 8 do
					local piece = row[x]
					if piece ~= nil and piece.colour == enemy_colour then
						print(piece.name)
						return table.getn(piece:get_valid_moves(piece_array)) == 0 
					end 
				end
			end, piece_array)
			
		end
		
		return false
	end
	
	if table.getn(enemy_king:get_valid_moves(piece_array)) > 0 then
		print("The king can escape")
		return false
	end

	-- Reach this point means that the enemy king is checked and has no valid moves to exit check
	local enemy_piece
	local game_over = true
	
	for x = 1, 8 do
		for y = 1, 8 do
			-- TODO: Clean up ifs
			enemy_piece = piece_array[x][y]
			-- if enemy_piece == nil then
			-- 	goto continue
			-- elseif enemy_piece.colour ~= enemy_king.colour then
			-- 	goto continue 
			-- end
			
			if enemy_piece ~= nil and enemy_piece.colour == enemy_king.colour then
				local piece_moves = enemy_piece:get_valid_moves(piece_array)
				local any_valid_moves = false
				for _, move in ipairs(piece_moves) do

					any_valid_moves = is_king_not_checkable(true, move, enemy_piece, piece_array)
					if any_valid_moves == true then
						print("NOT GAME OVER YET")
						print(enemy_piece.name, enemy_piece.pos[1], enemy_piece.pos[2], "-->", move[1], move[2])
						game_over = false
						return false
					end
				end
			end
			-- ::continue::
		end
	end
	return true

end

-- TODO: rename this function
function get_turn(current_state, valid, piece_colour)
	if current_state == GAME_STATE.TURN_WHITE then
		-- If a (W)HITE piece is trying to make a valid move then allow it
		valid = piece_colour == "w" and valid

		if valid then
			current_state = GAME_STATE.TURN_BLACK
		end

	elseif current_state == GAME_STATE.TURN_BLACK then

		-- If a (B)LACK piece is trying to make a valid move then allow it
		valid = piece_colour == "b" and valid
		if valid then
			current_state = GAME_STATE.TURN_WHITE
		end
	end
	
	return current_state, valid
end
