require "utils-module.utils"
require "piece.piece"
local rendercam = require "rendercam.rendercam"


-- Source: lua-users wiki
-- Function that clones a table and so we avoid the pass by reference error
function deepcopy(orig)
	local orig_type = type(orig)
	local copy
	if orig_type == 'table' then
		copy = {}
		for orig_key, orig_value in next, orig, nil do
			copy[deepcopy(orig_key)] = deepcopy(orig_value)
		end
		setmetatable(copy, deepcopy(getmetatable(orig)))
	else -- number, string, boolean, etc
		copy = orig
	end
	return copy
end


local piece_array = {}
piece_class = {p=Piece, n=Knight, r=Piece, b=Piece, k=Piece, q=Piece}

function init(self)
	msg.post(".", "acquire_input_focus")
	-- msg.post("#board", "play_animation", {id = hash("chess-king-white")} ) -- Set a sprite's animation
end

function on_message(self, message_id, message)
	print("MESSAGE:", message_id, message.id)
	if message_id == hash("piece_array") then
		piece_array = message.id
		-- pprint("INITIAL ARRAY:", piece_array)

		-- Loop through the piece array and replace 'constructor' tables with Piece function-objects
		for x, row in ipairs(piece_array) do
			for y, piece_table in ipairs(row) do
				local p = string.sub(piece_table["name"], 1, 1)
				local Class = piece_class[p] 
				local piece = Piece:new(piece_table["id"], piece_table["name"], {x, y}, false)

				-- Replace the piece_table with the Piece function-object
				piece_array[x][y] = deepcopy(piece)
			end
		end
	end

	-- Move Validation
	if message_id == hash("is_valid") then
		move_from = {}
		go_id = message.id[1]

		-- Get piece
		for x = 1, 8 do
			for y = 1, 8 do
				if piece_array[x][y] ~= nil then
					if piece_array[x][y].id == go_id then
						move_from = {x, y}
					end
				end
			end
		end
		
		local move_to = message.id[2]

		-- Error check
		if move_from[1] == nil then
			return
		end
		
		-- Get the piece
		local piece = deepcopy(piece_array[move_from[1]][move_from[2]])
		print("piece:", piece)
		
		valid, flag = piece:isValid(move_to, piece_array)
		print("VALIDITY:", valid, "FLAG:", flag)
		
		-- If valid Piece:move(pos) and update piece_array
		if valid then
			if flag == "capture" then
				local captured_go_id = piece_array[move_to[1]][move_to[2]].id
				msg.post(captured_go_id, "disable")
			end
			piece:move(move_to)

			-- Centre the piece in case it glitches out and just hovers over the captured square
			-- Put in function centre()
			local pos =  vmath.vector3(utils.get_px_from(piece.pos[2]), utils.get_px_from(utils.arr_coords[piece.pos[1]]), 0)
			go.set_position(pos, piece.id)
			
			-- Change to piece.scale
			go.set_scale(0.45, piece.id)
			
			-- Reflect positional changes in the piece_array
			piece_array[move_to[1]][move_to[2]] = piece
			piece_array[move_from[1]][move_from[2]] = nil
			print(piece_array[move_to[1]][move_to[2]], piece_array[move_from[1]][move_from[2]])
			
		else
			-- If the move is invalid, just take the piece back to the move_from location
			local prev_pos = vmath.vector3(utils.get_px_from(move_from[2]), utils.get_px_from(utils.arr_coords[move_from[1]]), 0)
			go.set_position(prev_pos, piece.id)
			
			-- Centre the piece in case it glitches out and just hovers over the captured square
			-- Put in function centre()
			local pos =  vmath.vector3(utils.get_px_from(piece.pos[2]), utils.get_px_from(utils.arr_coords[piece.pos[1]]), 0)
			go.set_position(pos, piece.id)

			-- Change to piece.scale
			go.set_scale(0.45, piece.id)
		end
	end
	
end


-- NEED TO BAKE PIECE NAME INTO GO NAME TO DIFFERNTIATE MORE EASILY
function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		print("Touch!")

		-- -- print(utils_px_to_xy(action.x, action.y))
		local pos = utils.px_to_xy({action.screen_x, action.screen_y})
		print(pos[1], pos[2], "--> " .. utils.get_equivalent(pos[1], pos[2]))
		print(piece_array[pos[1]][pos[2]])
		print(action.screen_x, action.screen_y)

		-- Move the clicked piece 1 space forward if white, and 1 down if black
		local clicked_go = piece_array[pos[1]][pos[2]]
		
		-- If an actual piece is clicked/tapped
	end
end
