require "utils-module.utils"
require "piece.piece"
local rendercam = require "rendercam.rendercam"

local piece_array = {}
local piece_class = {p=Piece, n=Piece, r=Piece, b=Piece, k=Piece, q=Piece}

-- Make all moves invalid while the King is in check
	-- Track king?
-- Turns - White --> Black --> White --> Black ...
-- Piece pinning - so X-Raying pieces can pin a piece if that piece's King is being protected by them
-- Game ending - if a king has no valid moves (which don't put him in check) it's over
local kings = {}

-- Keeps track of the last moved piece for (w)hite and (b)lack, so we can determine if en passant is truly valid
local team_colour = {
	["w"] = {last_moved_piece_id = nil}, 
	["b"] = {last_moved_piece_id = nil}
}

function init(self)
	msg.post(".", "acquire_input_focus")
end

function on_message(self, message_id, message)
	print("MESSAGE:", message_id, message.id)
	if message_id == hash("piece_array") then
		piece_array = message.id

		-- Loop through the piece array and replace 'constructor' tables with Piece function-objects
		for x, row in ipairs(piece_array) do
			for y, piece_table in ipairs(row) do
				local p = string.sub(piece_table["name"], 1, 1)
				local Class = piece_class[p] 
				local piece = Piece:new(piece_table["id"], piece_table["name"], {x, y}, false)

				-- Replace the piece_table with the Piece function-object
				piece_array[x][y] = deepcopy(piece)
			end
		end
	end

	-- Move Validation
	if message_id == hash("is_valid") then
		move_from = {}
		go_id = message.id[1]

		-- Get piece
		for x = 1, 8 do
			for y = 1, 8 do
				if piece_array[x][y] ~= nil then
					if piece_array[x][y].id == go_id then
						move_from = {x, y}
					end
				end
			end
		end
		
		local move_to = message.id[2]

		-- Error check
		if move_from[1] == nil then
			return
		end
		
		-- Get the piece
		local piece = deepcopy(piece_array[move_from[1]][move_from[2]])
		print("piece:", piece)
		
		valid, flag = piece:isValid(move_to, piece_array)
		print("VALIDITY:", valid, "FLAG:", flag)

		if flag == "en_passant" then
			local adjacent_pawn = piece_array[move_to[1] - 1][move_to[2]] or piece_array[move_to[1] + 1][move_to[2]]
			if adjacent_pawn.id ~= team_colour[adjacent_pawn.colour]["last_moved_piece_id"] then
				valid = false
			else
				msg.post(adjacent_pawn.id, "disable")
				piece_array[adjacent_pawn.pos[1]][adjacent_pawn.pos[2]] = nil
			end
		end
		
		-- If valid Piece:move(pos) and update piece_array
		if valid then
			if flag == "capture" then
				local captured_go_id = piece_array[move_to[1]][move_to[2]].id
				msg.post(captured_go_id, "disable")
				
			elseif flag == "castle" then 
				-- The king's valid function deals with this, no more needs to be done
				return
			end
			
			piece:move(move_to)

			-- Centre the piece in case it glitches out and just hovers over the captured square
			-- Put in function centre()
			local pos = vmath.vector3(utils.get_px_from(piece.pos[2]), utils.get_px_from(utils.arr_coords[piece.pos[1]]), 0)
			go.set_position(pos, piece.id)


			-- Change to piece.scale
			go.set_scale(0.45, piece.id)
			
			-- Reflect positional changes in the piece_array
			piece_array[move_to[1]][move_to[2]] = piece
			piece_array[move_from[1]][move_from[2]] = nil
			print(piece_array[move_to[1]][move_to[2]], piece_array[move_from[1]][move_from[2]])

			-- Track the last moved piece for en passant
			team_colour[piece.colour]["last_moved_piece_id"] = piece.id
			
		else
			-- If the move is invalid, just take the piece back to the move_from location
			local prev_pos = vmath.vector3(utils.get_px_from(move_from[2]), utils.get_px_from(utils.arr_coords[move_from[1]]), 0)
			go.set_position(prev_pos, piece.id)
			
			-- Centre the piece in case it glitches out and just hovers over the captured square
			-- Put in function centre()
			local pos =  vmath.vector3(utils.get_px_from(piece.pos[2]), utils.get_px_from(utils.arr_coords[piece.pos[1]]), 0)
			go.set_position(pos, piece.id)

			-- Change to piece.scale
			go.set_scale(0.45, piece.id)
		end
	end
	
end


function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		print("Touch!")

		-- -- print(utils_px_to_xy(action.x, action.y))
		local pos = utils.px_to_xy({action.screen_x, action.screen_y})
		print(pos[1], pos[2], "--> " .. utils.get_equivalent(pos[1], pos[2]))
		print(piece_array[pos[1]][pos[2]])
		print(action.screen_x, action.screen_y)

		-- Move the clicked piece 1 space forward if white, and 1 down if black
		local clicked_go = piece_array[pos[1]][pos[2]]
		
		-- If an actual piece is clicked/tapped
	end
end

-- [[ Helper Functions ]]

-- Source: lua-users wiki
-- Function that clones a table and so we avoid the pass by reference error
function deepcopy(orig)
	local orig_type = type(orig)
	local copy
	if orig_type == 'table' then
		copy = {}
		for orig_key, orig_value in next, orig, nil do
			copy[deepcopy(orig_key)] = deepcopy(orig_value)
		end
		setmetatable(copy, deepcopy(getmetatable(orig)))
	else -- number, string, boolean, etc
		copy = orig
	end
	return copy
end

