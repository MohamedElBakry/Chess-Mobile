require "utils-module.utils"
require "piece.piece"
local rendercam = require "rendercam.rendercam"

local piece_array = {}
local piece_class = {p=Piece, n=Piece, r=Piece, b=Piece, k=Piece, q=Piece}

-- Make all moves invalid while the King is in check
	-- Track king?
	-- Function: iterate over opposing pieces to see if they can 'capture' the king -- put him in check
-- Turns - White --> Black --> White --> Black ...
-- Piece pinning - so X-Raying pieces can pin a piece if that piece's King is being protected by them
-- Game ending - if a king has no valid moves (which don't put him in check) it's over

-- Keeps track of the last moved piece for (w)hite and (b)lack, so we can determine if en passant is truly valid
-- See Piece:__isvalid_pawn
local team_colour = {
	["w"] = {last_moved_piece_id = nil}, 
	["b"] = {last_moved_piece_id = nil}
}

function init(self)
	msg.post(".", "acquire_input_focus")
end

function on_message(self, message_id, message)
	print("MESSAGE:", message_id, message.id)
	if message_id == hash("piece_array") then
		piece_array = message.id

		-- Loop through the piece array and replace 'constructor' tables with Piece function-objects
		for x, row in ipairs(piece_array) do
			for y, piece_table in ipairs(row) do
				local piece = deepcopy(Piece:new(piece_table["id"], piece_table["name"], {x, y}, false))
				if piece.piece == "p" then
					piece.scale = piece.scale - 0.04  -- default scale is 0.45
				end
				
				-- Replace the piece_table with the Piece function-object
				piece_array[x][y] = piece
				
			end
		end
	end

	-- Move Validation
	if message_id == hash("is_valid") then
		move_from = {}
		go_id = message.id[1]

		-- Get piece
		for x = 1, 8 do
			for y = 1, 8 do
				if piece_array[x][y] ~= nil then
					if piece_array[x][y].id == go_id then
						move_from = {x, y}
					end
				end
			end
		end
		
		local move_to = message.id[2]

		-- Error check
		if move_from[1] == nil then
			return
		end
		
		-- Get the piece
		local piece = deepcopy(piece_array[move_from[1]][move_from[2]])
		print("piece:", piece)
		
		local valid, flag = piece:isValid(move_to, piece_array)
		print("VALIDITY:", valid, "FLAG:", flag)

		-- The king being in check overrides any move validation unless it's the king moving out of check
		-- as the king validation function would prevent that from happening
		-----========= look here
		valid = is_king_not_checkable(valid, flag, move_to, piece, piece.colour, piece_array)
		

		-- Check for specific movement flags
		if valid and flag == "en_passant" then
			local adjacent_pawn = piece_array[move_to[1] - 1][move_to[2]] or piece_array[move_to[1] + 1][move_to[2]]
			if adjacent_pawn.id ~= team_colour[adjacent_pawn.colour]["last_moved_piece_id"] then
				valid = false
			else
				msg.post(adjacent_pawn.id, "disable")
				piece_array[adjacent_pawn.pos[1]][adjacent_pawn.pos[2]] = nil
			end
		end
		
		-- If valid Piece:move(pos) and update piece_array
		if valid then
			if flag == "capture" then
				local captured_go_id = piece_array[move_to[1]][move_to[2]].id
				msg.post(captured_go_id, "disable")
				
			elseif flag == "castle" then 
				-- The king's valid function deals with this, no more needs to be done
				return
			end
			
			piece:move(move_to)

			-- Centre the piece in case it glitches out and just hovers over the captured square
			-- Put in function centre()
			local pos = vmath.vector3(utils.get_px_from(piece.pos[2]), utils.get_px_from(utils.arr_coords[piece.pos[1]]), 0)
			go.set_position(pos, piece.id)


			-- Change to piece.scale
			go.set_scale(piece.scale, piece.id)
			
			-- Reflect positional changes in the piece_array
			piece_array[move_to[1]][move_to[2]] = piece
			piece_array[move_from[1]][move_from[2]] = nil
			-- print(piece_array[move_to[1]][move_to[2]].name, ,"-->", piece_array[move_from[1]][move_from[2]])

			-- Track the last moved piece for en passant
			team_colour[piece.colour]["last_moved_piece_id"] = piece.id
			
		else
			-- If the move is invalid, just take the piece back to the move_from location
			local prev_pos = vmath.vector3(utils.get_px_from(move_from[2]), utils.get_px_from(utils.arr_coords[move_from[1]]), 0)
			go.set_position(prev_pos, piece.id)
			
			-- Centre the piece in case it glitches out and just hovers over the captured square
			-- Put in function centre()
			local pos =  vmath.vector3(utils.get_px_from(piece.pos[2]), utils.get_px_from(utils.arr_coords[piece.pos[1]]), 0)
			go.set_position(pos, piece.id)

			-- Change to piece.scale
			go.set_scale(piece.scale, piece.id)
		end
	end	
	show(piece_array)
end


function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		print("Touch!")

		-- -- print(utils_px_to_xy(action.x, action.y))
		local pos = utils.px_to_xy({action.screen_x, action.screen_y})
		print(pos[1], pos[2], "--> " .. utils.get_equivalent(pos[1], pos[2]))
		print(piece_array[pos[1]][pos[2]])
		print(action.screen_x, action.screen_y)

		-- Move the clicked piece 1 space forward if white, and 1 down if black
		local clicked_go = piece_array[pos[1]][pos[2]]
		
		-- If an actual piece is clicked/tapped
	end
end

-- [[ Helper Functions ]]

-- Source: lua-users wiki
-- Function that clones a table and so we avoid the pass by reference error
function deepcopy(orig)
	local orig_type = type(orig)
	local copy
	if orig_type == 'table' then
		copy = {}
		for orig_key, orig_value in next, orig, nil do
			copy[deepcopy(orig_key)] = deepcopy(orig_value)
		end
		setmetatable(copy, deepcopy(getmetatable(orig)))
	else -- number, string, boolean, etc
		copy = orig
	end
	return copy
end


-- Return bool
-- Iterate over the array to find the king of that colour, and see if he is in check
function is_king_in_check(colour, array) 
	for i, row in ipairs(array) do
		for i, piece in ipairs(row) do
			if piece ~= nil and piece.name == "k" .. colour then
				return piece.isChecked
			end
		end
	end
end

-- Return bool
-- Find the king and put him in check if a piece of the opposing colour can capture him
function is_king_not_checkable(valid, flag, move, moving_piece, colour, array)
	local king_pos = {}
	for x = 1, 8 do
		for y = 1, 8 do
			piece = array[x][y]
			if piece ~= nil and piece.name == "k" .. colour then
				king_pos = piece.pos
				goto is_capturable
			end
		end
	end
	
	-- TODO: do the move and undo it if neccessary???
	-- Make the move then check if the king can still be captured
	-- Then undo it regardless
	::is_capturable::
	
	if valid == false then
		return false
	end
	
	local temp_captured = deepcopy(array[move[1]][move[2]])
	array[move[1]][move[2]] = moving_piece
	
	array[moving_piece.pos[1]][moving_piece.pos[2]] = nil

	local piece_valid
	for x = 1, 8 do
		for y = 1, 8 do
			local piece = array[x][y]
			if piece ~= nil and piece.colour ~= colour then
				local piece_valid, piece_flag = piece:isValid(king_pos, array)	
				if piece_valid and piece_flag == "capture" then
					array[king_pos[1]][king_pos[2]].isChecked = true 
					array[move[1]][move[2]] = temp_captured
					array[moving_piece.pos[1]][moving_piece.pos[2]] = moving_piece
					return false
				end
			end
		end
	end

	array[move[1]][move[2]] = temp_captured
	array[moving_piece.pos[1]][moving_piece.pos[2]] = moving_piece
	return valid
	
end


function show(piece_array)
	local row_str = ""
	for x = 1, 8 do
		for y = 1, 8 do
			if piece_array[x][y] ~= nil then
				row_str = row_str .. piece_array[x][y].name .. ", "
			else
				row_str = row_str .. "  " .. ", "
			end
		end
		print(row_str)
		row_str = ""
	end
	return
end

