local utils = require "utils-module.utils"
local piece = require "piece.piece"
local rendercam = require "rendercam.rendercam"
local ai = require "game.ai"

local piece_array = {}

local GAME_STATE = utils.enum({"START", "END", "TURN_WHITE", "TURN_BLACK", "WIN_WHITE", "WIN_BLACK", "STALEMATE"})
local current_state = GAME_STATE.TURN_WHITE

-- Keeps track of the last moved piece for (w)hite and (b)lack, so we can determine if en passant is truly valid
-- See Piece:__isvalid_pawn
local team_colour = {
	["w"] = {last_moved_piece_id = nil}, 
	["b"] = {last_moved_piece_id = nil}
}


function init(self)
	msg.post(".", "acquire_input_focus")
end

function on_message(self, message_id, message)
	print("MESSAGE:", message_id, message.id)
	if message_id == hash("piece_array") then
		piece_array = message.id

		-- Loop through the piece array and replace 'constructor' tables with Piece function-objects
		for x, row in ipairs(piece_array) do
			for y, piece_table in ipairs(row) do
				local piece = utils.deepcopy(Piece:new(piece_table["id"], piece_table["name"], {x, y}, false))
				
				-- Replace the piece_table with the Piece function-object
				piece_array[x][y] = piece
				
			end
		end
	end
	
	-- Move Validation
	if message_id == hash("is_valid") then

		-- Get piece
		go_id = message.id[1]
		local move_from = get_piece_location(go_id)
		local move_to = message.id[2]
		print(move_from[1], move_from[2], "-->", move_to[1], move_to[2])

		-- Error check
		if move_from[1] == nil then
			print("move_from is nil... returning")
			return
		end
		
		-- Get the piece
		local piece = utils.deepcopy(piece_array[move_from[1]][move_from[2]])
		
		local valid, flag = piece:isValid(move_to, piece_array)
		print("VALIDITY:", valid, "FLAG:", flag)

		-- The king being in check overrides any move validation unless it's the king moving out of check
		-- as the king validation function would prevent that from happening
		valid = is_king_not_checkable(valid, move_to, piece, piece_array)
		
		-- Final check that overrides all other checks to see if the correct team is moving a piece
		current_state, valid = get(current_state, valid, piece.colour)

		-- Check for specific movement flags
		if valid and flag == "en_passant" then
			
			local adjacent_pawn = piece_array[move_to[1] - 1][move_to[2]] or piece_array[move_to[1] + 1][move_to[2]]
			if adjacent_pawn.id ~= team_colour[adjacent_pawn.colour]["last_moved_piece_id"] then
				valid = false
				
			else
				msg.post(adjacent_pawn.id, "disable")
				piece_array[adjacent_pawn.pos[1]][adjacent_pawn.pos[2]] = nil
			end
		end
		
		-- If valid Piece:move(pos) and update piece_array
		if valid then
			get_king(piece.colour, piece_array).isChecked = false
			
			if flag == "capture" then
				local captured_go_id = piece_array[move_to[1]][move_to[2]].id
				msg.post(captured_go_id, "disable")
				
			elseif flag == "castle" then 
				-- The king's valid function deals with this, no more needs to be done
				return
			end

			piece:move(move_to, piece_array)

			-- Centre the piece in case it glitches out and just hovers over the captured square
			centre(piece.pos, piece.id, piece.scale)

			-- Track the last moved piece for en passant
			team_colour[piece.colour]["last_moved_piece_id"] = piece.id

			-- CHECKMATE?
			-- If the enemy king is in check, and has no valid moves,
			-- and there are no moves by his pieces that will put him out of check, then there's a winner
			local game_over = is_checkmate(piece.colour, piece_array)
			if game_over and current_state == GAME_STATE.TURN_WHITE then
				current_state = GAME_STATE.WIN_WHITE
				
			elseif game_over and current_state == GAME_STATE.TURN_BLACK then
				current_state = GAME_STATE.WIN_BLACK
			end
			

		else
			-- If the move is invalid, just take the piece back to the move_from location
			centre(move_from, piece.id, piece.scale)
			
		end
	end

	show(piece_array)
	print(ai.evaluate(piece_array))
	
	
	return
end

-- [[ Helper Functions ]]
-- TODO: Make Game class to 'do' and undo moves? 


function show(piece_array)
	local row_str = ""
	for x = 1, 8 do
		for y = 1, 8 do
			if piece_array[x][y] ~= nil then
				row_str = row_str .. piece_array[x][y].name .. ", "
			else
				row_str = row_str .. "  " .. ", "
			end
		end
		print(row_str)
		row_str = ""
	end
	return
end


function centre(piece_pos, piece_id, piece_scale)
	local pos = vmath.vector3(utils.get_px_from(piece_pos[2]), utils.get_px_from(utils.arr_coords[piece_pos[1]]), 0)
	go.set_position(pos, piece_id)

	-- Change to piece.scale
	go.set_scale(piece_scale, piece_id)
	
end

-- Validation helper function(s)

function get_piece_location(go_id)
	local move_from = {}

	-- Get piece
	for x = 1, 8 do
		for y = 1, 8 do
			if piece_array[x][y] ~= nil then
				if piece_array[x][y].id == go_id then
					move_from = {x, y}
				end
			end
		end
	end

	return move_from
end


function is_checkmate(piece_colour, piece_array)
	
	local enemy_colour = "w"
	if piece_colour == "w" then
		enemy_colour = "b"
	end

	local enemy_king = get_king(enemy_colour, piece_array)

	-- Check if the enemy king is now in check
	local our_piece, our_piece_flag
	for x = 1, 8 do 
		for y = 1, 8 do
			our_piece = piece_array[x][y]

			if our_piece ~= nil and our_piece.colour == piece_colour then
				
				our_piece_valid, our_piece_flag = our_piece:isValid(enemy_king.pos, piece_array)
				if our_piece_valid and our_piece_flag == "capture" then
					enemy_king.isChecked = true
					goto is_checked
				end
			end
		end
	end

	::is_checked::
	if enemy_king.isChecked == false then
		print("The " .. enemy_colour .. " king is not threatend")
		return false
	end
	
	if table.getn(enemy_king:get_valid_moves(piece_array)) > 0 then
		print("The king can escape")
		return false
	end

	-- Reach this point means that the enemy king is checked and has no valid moves to exit check
	local enemy_piece
	local game_over = true
	
	for x = 1, 8 do
		for y = 1, 8 do
			-- TODO: Clean up ifs
			enemy_piece = piece_array[x][y]
			-- if enemy_piece == nil then
			-- 	goto continue
			-- elseif enemy_piece.colour ~= enemy_king.colour then
			-- 	goto continue 
			-- end
			
			if enemy_piece ~= nil and enemy_piece.colour == enemy_king.colour then
				local piece_moves = enemy_piece:get_valid_moves(piece_array)
				local any_valid_moves = false
				for _, move in ipairs(piece_moves) do

					any_valid_moves = is_king_not_checkable(true, move, enemy_piece, piece_array)
					if any_valid_moves == true then
						print("NOT GAME OVER YET")
						print(enemy_piece.name, enemy_piece.pos[1], enemy_piece.pos[2], "-->", move[1], move[2])
						game_over = false
						return false
					end
				end
			end
			-- ::continue::
		end
	end
	return true

end

-- TODO: rename this function
function get(current_state, valid, piece_colour)
	if current_state == GAME_STATE.TURN_WHITE then
		-- If a (W)HITE piece is trying to make a valid move then allow it
		valid = piece_colour == "w" and valid

		if valid then
			current_state = GAME_STATE.TURN_BLACK
		end

	elseif current_state == GAME_STATE.TURN_BLACK then

		-- If a (B)LACK piece is trying to make a valid move then allow it
		valid = piece_colour == "b" and valid
		if valid then
			current_state = GAME_STATE.TURN_WHITE
		end
	end
	
	return current_state, valid
end
